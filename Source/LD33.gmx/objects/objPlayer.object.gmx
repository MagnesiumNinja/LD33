<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayer</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>objMoveEntity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Physics objects must call the parent object's create event
// Initialize the player as a physics object
event_inherited();


enum PlayerStates
{
    PHYSICAL,
    SHADOW
}

enum ShadowPos
{
    TOP,
    LEFT,
    RIGHT,
    BOTTOM
}

//////////////////////////
// FUNCTIONAL CONSTANTS //
//////////////////////////

// PHYSICS //
GRAVITY = 0.4;
RUN_ACCEL = 0.85; // For moving on the ground
RUN_FRIC = 0.9;
AIR_ACCEL = 0.75; // For moving left and right in the air
AIR_FRIC = 0.7;

// SPEED //
MAX_H = 11;
MAX_V = 25;
JUMP_SPEED = -14;
DOUBLE_JUMP_SPEED = -10;
WALL_JUMP_VERT_SPEED = -14;
WALL_JUMP_HOR_SPEED = 8;
WALL_JUMP_STICK_BUFFER = 16; // Pixels away from wall where you can still jump
MAX_V_WALLSLIDE = MAX_V / 3;
FALL_SHAKE_THRESHOLD = 20; // Speed at which impact will cause screenshake
SLOPE_SLOW = 0.7; // Speed factor on slope

DASH_SPEED = 24;


// PLAYER ACTIONS //
NUM_DOUBLE_JUMPS = 1;


//////////////////////////
// FUNCTIONAL VARIABLES //
//////////////////////////


// STATE //

state = PlayerStates.PHYSICAL;


// PHYSICAL //

// Movement
doubleJumps = NUM_DOUBLE_JUMPS;
canHoldJump = true; // Can hold down the jump button to increase height
dirSwitch = false;
wallsliding = false;
canWallJump = false;


// SHADOW //

shadowPos = ShadowPos.BOTTOM;
dashing = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// ACCELERATION AND FRICTION //

var accel, fric;

if (onGround) 
{
    accel = RUN_ACCEL;
    fric = RUN_FRIC;
}
else 
{
    accel = AIR_ACCEL;
    fric = AIR_FRIC;
}


// PLAYER INPUT //

switch(state)
{
    case PlayerStates.PHYSICAL:
    {
        dashing = false;
    
        // MOVEMENT //
        
        if (keyboard_check(global.KEY_LEFT) &amp;&amp; !keyboard_check(global.KEY_RIGHT) &amp;&amp; !place_meeting(x - 1, y, objBlock))
        {
            // Move left
            if (hspdPrev &gt; 0)
            {
                hspd = approach(hspd, 0, fric);
                dirSwitch = true;
            }
            else
            {
                dirSwitch = false;   
            }
            
            hspd = approach(hspd, -MAX_H, accel);
        }
        else if (keyboard_check(global.KEY_RIGHT) &amp;&amp; !keyboard_check(global.KEY_LEFT) &amp;&amp; !place_meeting(x + 1, y, objBlock))
        {
            // Move right
            if (hspdPrev &lt; 0)
            {
                hspd = approach(hspd, 0, fric);
                dirSwitch = true;
            }
            else
            {
                dirSwitch = false;   
            }
            
            hspd = approach(hspd, MAX_H, accel);
        }
        else
        {
            // Stop
            hspd = approach(hspd, 0, fric);
            dirSwitch = false;
        }
        
        // Switching states
        if (mouse_check_button_pressed(global.KEY_SWAP))
        {
            if (place_meeting(x - 1, y, objBlock))
            {
                state = PlayerStates.SHADOW;
                shadowPos = ShadowPos.LEFT;
            }
            else if (place_meeting(x + 1, y, objBlock))
            {
                state = PlayerStates.SHADOW;
                shadowPos = ShadowPos.RIGHT;
            }
            else if (place_meeting(x, y - 1, objBlock))
            {
                state = PlayerStates.SHADOW;
                shadowPos = ShadowPos.TOP;     
            }
            else if (place_meeting(x, y + 1, objBlock))
            {
                state = PlayerStates.SHADOW;
                shadowPos = ShadowPos.BOTTOM;            
            }
        }
        
        
        if (onGround)
        {
            // GROUND //
            
            vspd = 0;
            doubleJumps = NUM_DOUBLE_JUMPS;
            
            if (keyboard_check_pressed(global.KEY_UP))
            {
                canHoldJump = true;
                vspd = JUMP_SPEED;
            }
            
            // Wall Sliding
            if (wallsliding)
            {
                wallsliding = false;
            }
        }
        else
        {
            // AIR //
            
            // Gravity
            if (((place_meeting(x - 1, y, objBlock) &amp;&amp; place_meeting(x - 1, y - 2, objBlock)) || (place_meeting(x + 1, y - 2, objBlock) &amp;&amp; place_meeting(x + 1, y, objBlock))) &amp;&amp; vspd &gt; 0)
            {
                vspd = approach(vspd, MAX_V_WALLSLIDE, GRAVITY / 3);
                
                if (!wallsliding)
                {
                    wallsliding = true;
                }
            }
            else
            {   
                vspd = approach(vspd, MAX_V, GRAVITY);
                
                if (wallsliding)
                {
                    wallsliding = false;
                }
            }
            
            if (vspd == 0)
            {
                if (wallsliding)
                {
                    wallsliding = false;
                }
            }
            
            
            // Variable jump height
            if ((!keyboard_check(global.KEY_UP) || !canHoldJump) &amp;&amp; vspd &lt; 0)
            {
                vspd /= 2;
            }
            
            // Double jump
            if (keyboard_check_pressed(global.KEY_UP) &amp;&amp; doubleJumps &gt; 0)
            {
                doubleJumps--;
                
                canHoldJump = true;
                vspd = DOUBLE_JUMP_SPEED;
            }
            
            // Wall Jump
            if (canWallJump &amp;&amp; keyboard_check_pressed(global.KEY_UP))
            {
                callWallJump = false;
                canHoldJump = true;
                
                vspd = WALL_JUMP_VERT_SPEED;
                
                if (place_meeting(x - WALL_JUMP_STICK_BUFFER - 2, y, objBlock)) 
                {
                    hspd = WALL_JUMP_HOR_SPEED;
                } else 
                {
                    hspd = -WALL_JUMP_HOR_SPEED;
                }
            }
            
        }
        
        
        // WALL JUMP CHECK //
        
        if (((place_meeting(x - 1, y, objBlock) &amp;&amp; place_meeting(x - 1, y - 2, objBlock)) || (place_meeting(x + 1, y - 2, objBlock) &amp;&amp; place_meeting(x + 1, y, objBlock))) &amp;&amp; !onGround) 
        {
            canWallJump = true;
        }
        else if ((!place_meeting(x - WALL_JUMP_STICK_BUFFER, y, objBlock) &amp;&amp; !place_meeting(x + WALL_JUMP_STICK_BUFFER, y, objBlock)))
        {
            canWallJump = false;
        }
        
        break;
    }
    
    
    case PlayerStates.SHADOW:
    {
        if (!dashing)
        {
            // Horizontal Movement
            if (shadowPos == ShadowPos.BOTTOM || shadowPos == ShadowPos.TOP)
            {
                vspd = 0;
            
                if (keyboard_check(global.KEY_LEFT))
                {
                    // Move left
                    if (hspdPrev &gt; 0)
                    {
                        hspd = approach(hspd, 0, fric);
                        dirSwitch = true;
                    }
                    else
                    {
                        dirSwitch = false;   
                    }
                    
                    hspd = approach(hspd, -MAX_H, accel);
                    
                    if (!collision_point(bbox_left - hspd, bbox_top - 1, objBlock, false, true) &amp;&amp; !collision_point(bbox_left - hspd, bbox_bottom + 1, objBlock, false, true))
                    {
                        hspd = 0;
                    }
                }
                else if (keyboard_check(global.KEY_RIGHT))
                {
                    // Move right
                    if (hspdPrev &lt; 0)
                    {
                        hspd = approach(hspd, 0, fric);
                        dirSwitch = true;
                    }
                    else
                    {
                        dirSwitch = false;   
                    }
                    
                    hspd = approach(hspd, MAX_H, accel);
                    
                    if (!collision_point(bbox_right + hspd, bbox_top - 1, objBlock, false, true) &amp;&amp; !collision_point(bbox_right + hspd, bbox_bottom + 1, objBlock, false, true))
                    {
                        hspd = 0;
                    }
                }
                else
                {
                    // Stop
                    hspd = approach(hspd, 0, fric);
                    dirSwitch = false;
                }
            }    
            else if (shadowPos == ShadowPos.LEFT || shadowPos == ShadowPos.RIGHT)
            {
                // Vertical Movement
                hspd = 0;
            
                if (keyboard_check(global.KEY_UP))
                {
                    // Move up
                    if (vspdPrev &gt; 0)
                    {
                        vspd = approach(vspd, 0, fric);
                        dirSwitch = true;
                    }
                    else
                    {
                        dirSwitch = false;   
                    }
                    
                    vspd = approach(vspd, -MAX_H, accel);
                    
                    if (!collision_point(bbox_left - 1, bbox_top - vspd, objBlock, false, true) &amp;&amp; !collision_point(bbox_right + 1, bbox_top - vspd, objBlock, false, true))
                    {
                        vspd = 0;
                    }
                }
                else if (keyboard_check(global.KEY_DOWN))
                {
                    // Move down
                    if (vspdPrev &lt; 0)
                    {
                        vspd = approach(vspd, 0, fric);
                        dirSwitch = true;
                    }
                    else
                    {
                        dirSwitch = false;   
                    }
                    
                    vspd = approach(vspd, MAX_H, accel);
                    
                    if (!collision_point(bbox_left - 1, bbox_bottom + vspd, objBlock, false, true) &amp;&amp; !collision_point(bbox_right + 1, bbox_bottom + vspd, objBlock, false, true))
                    {
                        vspd = 0;
                    }
                }
                else
                {
                    // Stop
                    vspd = approach(vspd, 0, fric);
                    dirSwitch = false;
                }
            }
        }
        else
        {
            // Dashing
            if (place_meeting(x + hspd, y + vspd, objBlock))
            {
                dashing = false;
            }
        }
        
        // Dashing
        if (mouse_check_button_pressed(global.KEY_DASH) &amp;&amp; !dashing)
        {
            dashing = true;
            
            // Retrieve dash angle
            var dashDir = point_direction(x, y, mouse_x, mouse_y);
            
            hspd = lengthdir_x(DASH_SPEED, dashDir);
            vspd = lengthdir_y(DASH_SPEED, dashDir);    
        }
    
        // Leaving Shadow 
        if (mouse_check_button_pressed(global.KEY_SWAP))
        {
            state = PlayerStates.PHYSICAL;
        }
        
        break;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>switch(state)
{
    case PlayerStates.PHYSICAL:
    {
        draw_self();
        
        break;
    }
    
    case PlayerStates.SHADOW:
    {
        draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, image_yscale, image_angle, c_black, 1);
        break;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
